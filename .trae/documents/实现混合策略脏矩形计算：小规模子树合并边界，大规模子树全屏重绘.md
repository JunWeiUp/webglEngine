# 针对百万级节点的性能优化方案

要实现超过 100 万节点时的流畅缩放和平移，关键在于**避免全量遍历**。
目前的渲染管线在每帧都会递归遍历整个场景树（O(N)），进行矩阵更新和视锥剔除。对于 100 万个节点，即使不做任何绘制，光是 CPU 遍历和矩阵乘法就会造成严重卡顿。

**核心策略：静态层 (StaticLayer) + 局部空间索引 (Local Space Indexing)**

1.  **引入 `StaticLayer` 容器**：
    *   专为大量**相对静止**的物体（如地图图标、植被、粒子）设计。
    *   内部维护一个基于 **局部坐标** 的 **QuadTree**。
    *   **关键优化**：由于 QuadTree 存储的是相对于 Layer 的局部坐标，当 Layer 本身平移或缩放时，**QuadTree 不需要重建或更新**。这消除了场景变换时的巨大 CPU 开销。

2.  **按需更新与渲染 (Culling & Lazy Update)**：
    *   在 `renderWebGL` 阶段，先将视口（Viewport）逆变换到 `StaticLayer` 的局部空间。
    *   利用 QuadTree 查询出当前局部视口内的可见子节点（例如从 100 万个中筛选出 500 个）。
    *   **仅对这 500 个可见节点** 执行 `updateTransform`（计算世界矩阵）和 `renderWebGL`。
    *   跳过其余 99.95% 不可见节点的 CPU 计算。

3.  **实现细节**：
    *   修改 `QuadTree` 以支持自定义的包围盒获取逻辑（支持 Local AABB）。
    *   创建 `StaticLayer.ts`，重写 `addChild`, `removeChild`, `renderWebGL`, `updateTransform`。

通过这种方式，渲染和更新的开销将只与**屏幕内可见节点的数量**成正比，而与场景总节点数无关。理论上可支持无限数量的节点，只要内存放得下。

## 执行计划

1.  **修改 `QuadTree.ts`**：增加配置项或回调，使其能基于节点的 `局部坐标` (Local Bounds) 而非 `世界坐标` 构建索引。
2.  **创建 `src/engine/display/StaticLayer.ts`**：实现上述的按需渲染逻辑。
3.  **验证**：在 `main.ts` 中使用 `StaticLayer` 替代普通 `Container` 来承载大量 Sprite。
