基于深入分析，我确定了最后两个能够带来**大幅（数量级）**性能提升的关键优化点：

1.  **静态批处理 (Static Batching / Geometry Baking)**
    *   **现状**: 即使使用了 Sector 分块，对于屏幕内可见的 2500+ 个物体，CPU 每一帧仍需遍历它们，计算顶点数据并写入缓冲区。这在物体不移动的情况下是巨大的浪费。
    *   **优化**: 引入 `StaticBatch` 容器。
        *   它会将子节点的所有几何信息“烘焙”到一个静态的 GPU 缓冲区（VBO）中。
        *   渲染时，直接绑定该缓冲区并执行一次绘制调用（Draw Call），跳过所有子节点的 CPU 遍历和变换计算。
        *   **效果**: 对于地图底图、建筑标记等静态元素，渲染开销几乎降为零。

2.  **文本位图化 (Bitmap Text Caching)**
    *   **现状**: 目前 `Text` 对象使用 Canvas 2D API 绘制在覆盖层上。当屏幕上有数千个文本时，Canvas 2D 的重绘（尤其是 `fillText`）会成为严重的 CPU 瓶颈，且无法参与 WebGL 的深度排序。
    *   **优化**: 将 `Text` 升级为支持 WebGL 渲染。
        *   在文本内容改变时，将其绘制到一个离屏 Canvas 并生成 WebGL 纹理。
        *   在渲染循环中，将其视为一个普通的 `Sprite` 进行批处理渲染。
    *   **效果**: 文本渲染速度提升 10-100 倍，并且可以正确地跟随 Camera 缩放而不模糊（如果处理得当）或至少性能不再是瓶颈。

### 执行计划

1.  **升级 `Text.ts`**:
    *   实现 `cacheAsBitmap` 逻辑，将文本转换为 `Texture`。
    *   实现 `renderWebGL` 方法，使其能像 Sprite 一样被渲染器处理。

2.  **实现 `StaticBatch.ts`**:
    *   创建一个新的节点类型，用于管理静态几何体。
    *   实现 `compile()` 方法用于生成 VBO。
    *   实现 `renderWebGL()` 方法用于提交静态 Draw Call。

3.  **更新 `Renderer.ts`**:
    *   添加对静态 VBO 渲染的支持接口。

4.  **更新 `main.ts`**:
    *   将 `Sector` 容器替换为 `StaticBatch` 容器（或包含它），启用文本的 WebGL 模式。

我是否应该执行这些优化？