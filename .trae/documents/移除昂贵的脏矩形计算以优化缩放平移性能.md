# WebGL 性能终极优化计划：移除冗余的 Dirty Rect 计算

用户反馈缩放平移依然卡顿。我们已经解决了纹理上传、GC、Draw Call 等问题。现在剩下的最大瓶颈是 **CPU 计算开销**。

## 深入分析
在 `Node.ts` 中，我们发现了一个非常昂贵的操作：**`invalidateWithChange`**。
每当节点的 `x, y, scale, rotation` 发生变化时（在缩放平移时，根节点或容器节点的这些属性会频繁变化），都会触发这个方法。

```typescript
    private invalidateWithChange(changeFn: () => void) {
        // 1. 捕获变化前的世界包围盒 (包括所有子节点)
        const oldRect = this.getBounds(true); // <--- 昂贵！递归遍历所有子节点

        // 2. 应用变化
        changeFn();

        // 3. 立即更新变换以获取新的世界包围盒
        this.updateTransform(...);

        // 4. 获取变化后的世界包围盒 (包括所有子节点)
        const newRect = this.getBounds(true); // <--- 昂贵！再次递归遍历所有子节点

        // ... 计算并集 ...
    }
```

**灾难性的性能开销**：
如果场景中有 10000 个节点，当你平移根节点时：
1.  根节点 `x` 变化。
2.  调用 `getBounds(true)`：递归计算 10000 个节点的包围盒并合并（涉及 10000 次矩阵运算）。
3.  应用变化，更新变换。
4.  再次调用 `getBounds(true)`：又一次递归 10000 个节点。

这意味着仅仅为了移动一下根节点，CPU 进行了 **20000 次** 额外的包围盒计算和合并操作！而在 WebGL 全屏渲染模式下，我们其实**根本不需要知道具体的脏矩形**（直接全屏重绘即可，或者只有在局部更新时才需要脏矩形）。

在缩放/平移整个场景时，通常意味着全屏内容都变了，此时计算精确的脏矩形不仅无用，反而是巨大的负担。

## 解决方案

1.  **优化 `invalidate` 策略**：
    *   引入一个标志位（如 `Engine.fullInvalidate`），当检测到根节点或主要容器发生变换时，直接触发全屏重绘，**跳过脏矩形计算**。
    *   修改 `Node.ts`，不再强制计算 `oldRect` 和 `newRect`。
    *   **快速路径**：如果 `Node` 是根节点（或其子节点数量巨大），或者引擎处于“全屏重绘模式”，则直接调用 `invalidate()` 而不带参数（表示全屏脏）。

2.  **修改 `Node.ts`**：
    *   移除 `invalidateWithChange` 中昂贵的 `getBounds` 调用。
    *   改为：属性变化 -> 标记 `transform.dirty` -> 调用 `invalidate()`。
    *   `invalidate()` 向上冒泡，根节点接收到后，决定是全屏重绘还是局部重绘。

    *注意：脏矩形优化主要用于 Canvas 2D 时代，为了减少 `clearRect` 和 `drawImage` 的面积。在 WebGL 中，全屏 `clear` 和批处理绘制通常比 CPU 计算复杂的脏矩形合并要快得多，特别是当大部分内容都在动的时候。*

## 执行计划

1.  **修改 `Node.ts`**：
    *   重构 `x, y, scale, rotation` 的 setter。
    *   移除 `invalidateWithChange` 及其对 `getBounds` 的调用。
    *   直接调用 `changeFn()` 然后 `this.invalidate()`。

2.  **验证**：
    *   确认平移/缩放时，不再有大量的递归计算。
    *   确认渲染依然正确（`Engine` 接收到无参数的 `invalidate()` 会触发 `invalidateFull()`）。

这是性能优化的关键一步，将把复杂度从 O(N) 降低到 O(1)（对于变换操作）。
