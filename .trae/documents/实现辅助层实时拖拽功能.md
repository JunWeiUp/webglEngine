我将把拖拽模式从“代理拖拽”（Proxy Dragging）改为“实时拖拽”（Real-time Dragging）。这意味着在拖拽过程中，物体本身会实时跟随鼠标移动，而不是只显示一个半透明的影子。

具体计划如下：

1.  **修改 `InteractionManager.ts`**：
    *   **移除 Proxy 逻辑**：不再更新 `auxLayer.dragProxyPos`。
    *   **实时移动物体**：在 `onMouseMove` 中，直接计算鼠标的增量（Delta），并将该增量应用到 `draggingNode` 的 `transform.position` 上。
    *   **坐标转换**：需要注意，物体当前处于某个父节点下，所以鼠标的屏幕增量需要转换为父节点的局部坐标系增量。这部分逻辑在我之前的版本中已经实现过，可以直接复用（`mat3.invert` 父节点的世界矩阵）。
    *   **放置（Drop）逻辑调整**：
        *   在 `onMouseUp` 时，如果发生了 Reparent（切换父节点）：
            1.  计算物体当前的**世界坐标**。
            2.  将物体从旧父节点移除，添加到新父节点。
            3.  计算新父节点下的**局部坐标**，以保持物体的世界位置不变。
        *   如果没有切换父节点，则不需要做额外处理，因为物体已经在 `onMouseMove` 中移动到了正确位置。

2.  **修改 `AuxiliaryLayer.ts`**：
    *   **移除 Ghost 绘制**：不再绘制跟随鼠标的半透明方块。
    *   **保留高亮**：依然保留对 Hover 目标容器的高亮（绿色边框），提示用户可以放入。
    *   **选中框跟随**：由于物体位置实时更新，选中框（蓝色）也会自动跟随物体移动。

3.  **流程**：
    *   `MouseDown`: 选中物体，记录初始位置。
    *   `MouseMove`: 计算鼠标位移 -> 转换到父节点局部空间 -> 更新物体位置 -> 物体在屏幕上跟随鼠标移动。同时检测下方的潜在新父节点，并在辅助层高亮它。
    *   `MouseUp`: 如果有有效的新父节点 -> 执行 Reparent（保持世界坐标不变）。

这将提供更流畅、更直观的拖拽体验。