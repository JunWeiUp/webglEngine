# 解决拖拽时的残影问题

用户反馈在拖拽子部件超出父容器时会出现残影。

## 原因分析

这个问题通常与 **脏矩形渲染 (Dirty Rect Rendering)** 及其 **清除策略 (Clear Strategy)** 有关。

1. **脏矩形计算**：当一个节点移动时，我们需要重绘两个区域：

   * **旧位置**（清除残留）

   * **新位置**（绘制新状态）
     我们目前的 `Node.ts` 中已经在 setter 中实现了这一点（通过 `invalidateWithSelfBounds` 取并集）。

2. **Scissor Test 与 Clear**：
   在 `Renderer.render` 中，如果提供了 `dirtyRect`，我们会启用 `gl.scissor` 并调用 `gl.clear`。

   ```typescript
   if (dirtyRect) {
       this.gl.enable(this.gl.SCISSOR_TEST);
       this.gl.scissor(...);
       this.gl.clear(...); // <--- 关键点
   }
   ```

   这会清除脏矩形区域内的**所有内容**（背景色），然后重绘该区域内的所有节点。

3. **残影来源**：
   如果子节点被拖出了父节点的边界，且父节点（或某个祖先）没有重绘其背景，或者脏矩形计算不正确，就会导致旧位置的像素没被清除。

   但在我们的架构中，`Renderer` 是清除整个 Scissor 区域的背景色 (`gl.clearColor`)。所以只要脏矩形覆盖了旧位置，旧位置就会被清除为背景色。

   **真正的潜在原因：Scissor 裁剪了父节点的重绘？**
   如果我们在拖拽一个子节点，触发了局部重绘。脏矩形包含了子节点的旧位置和新位置。
   渲染器会：

   1. 设置 Scissor 为脏矩形。
   2. Clear (变黑/白)。
   3. 重绘场景中与脏矩形相交的所有节点。

   **如果子节点超出了父节点**：
   父节点可能是一个容器（Container），它本身可能不渲染任何东西，或者渲染一个背景。
   如果子节点移出了父节点的范围，进入了另一个区域（可能是另一个节点的领地，或者是空白背景）。
   只要脏矩形正确，并且 `render` 遍历了所有受影响的节点，就不应该有残影。

   **除了 AuxLayer**：
   拖拽操作通常是在 `AuxiliaryLayer` 或直接修改 `Node` 属性。
   如果是直接修改 `Node` 属性（如 `InteractionManager` 中做的），`Node` 会触发 `invalidate`。

   **AuxiliaryLayer 的问题**：
   `AuxiliaryLayer` (Canvas 2D) 通常用于绘制选框、高亮框。
   如果用户说的“残影”是指 **高亮框** 或 **拖拽代理** 的残影，那是因为 `AuxiliaryLayer` 的清除逻辑可能有问题。
   但在 `InteractionManager` 中，拖拽是直接修改场景图节点的 `x, y`。

   **WebGL 残影的特殊情况**：
   `preserveDrawingBuffer: true`。我们在 `Renderer` 中开启了这个。
   这意味着我们需要手动清除上一帧的内容。`gl.clear` 确实做了。

   **那么，为什么会有残影？**
   一种可能性是：**脏矩形计算漏了某些区域**。
   当子节点从父节点内部移出时，`Node` 的 `invalidateWithSelfBounds` 计算的是子节点自身的 World AABB。
   这个 World AABB 是正确的。

   **另一种可能性：父节点的** **`overflow: hidden`** **(Masking)?**
   如果引擎支持 Mask，且 Mask 没更新，可能会导致裁剪异常。但我们目前没有 Mask。

   **最可能的解释：渲染顺序或层级问题**
   当子节点移动时，它下方的物体（可能是父节点背景，也可能是其他兄弟节点）需要重绘。
   由于我们是清除脏矩形区域并重绘**整个场景**（在脏矩形内的部分），所以下方的物体应该会被重绘。

   **除非...** **`isNodeVisible`** **剔除错误？**
   当渲染脏矩形区域时，我们需要确保**所有与脏矩形相交的节点**都被绘制。
   如果某个底层的节点（如大背景）被错误地剔除了，那么 Clear 后的区域就没有背景了（显示为 ClearColor，通常是黑色或灰色）。如果 ClearColor 与之前的背景不同，看起来像个黑洞；如果 ClearColor 透明且 Canvas 透明，可能看到网页背景。
   但如果用户说的是“残影”（Ghosting），通常指**旧的内容没被擦除**。
   这意味着 `gl.clear` 没执行，或者 Scissor 区域不对。

   **等等，用户提到 "子部件超出父亲"**。
   在 DOM 中，`overflow: visible` 会导致子元素画在父元素外面。
   在 WebGL 中，如果没有 Mask，子元素当然可以画在父元素外面。

   **让我们看下** **`InteractionManager`** **的拖拽逻辑**：

   ```typescript
   node.x += localDeltaX;
   node.y += localDeltaY;
   ```

   这会触发 `node.x` setter -> `invalidateWithSelfBounds`。

   如果父节点移动了，子节点也会动。

   **关键点：`updateTransform`** **的时机**。
   在 `invalidateWithSelfBounds` 中：

   ```typescript
   const oldRect = this.getBounds(false);
   changeFn(); // 修改 x, y
   this.updateTransform(this.parent!.transform.worldMatrix, true); // 更新矩阵
   const newRect = this.getBounds(false);
   ```

   这里手动调用了 `updateTransform`。

   如果 `this.parent` 的 WorldMatrix 也是脏的（例如父节点也在动），传入的 `this.parent.transform.worldMatrix` 可能是旧的！
   **但是**，在拖拽单个节点时，通常父节点不动。

   **如果拖拽的是父节点？**
   `InteractionManager` 会移动所有选中的顶层节点。
   如果选中了父节点，子节点会跟随移动。
   父节点 setter -> `invalidate` (如果是容器且无尺寸 -> 全屏重绘)。
   如果父节点有尺寸（如 Sprite 作为容器） -> 局部重绘。
   此时子节点也会移动。但父节点的 `getBounds(false)` **只包含父节点自身**。
   **子节点的移动没有被计入脏矩形！**

   **Bingo!**
   如果我移动一个 `Sprite`（作为容器），它包含一个 `Child Sprite`（位置在父节点之外）。
   父节点触发 setter -> 计算父节点自身的 Old/New Rect -> 提交脏矩形。
   **子节点虽然跟着动了，但它的区域没有被包含在脏矩形中！**
   因此，子节点的旧位置没有被清除，新位置也没有被绘制（或者被剪裁）。
   这就导致了子节点的残影。

## 解决方案

**必须计算包含所有子节点的脏矩形**，或者**当节点有子节点时，回退到全屏重绘**（或者更激进的脏矩形策略）。

鉴于我们之前为了性能移除了递归计算 `getBounds(true)`。
现在我们面临两难：

1. **高性能**：只计算自身，忽略子节点（导致残影）。
2. **正确性**：递归计算子节点（导致卡顿）。

**折中方案**：

1. **判断是否有子节点**：如果一个节点有 `children.length > 0`，且正在发生变换，我们应该：

   * **方案 A**: 强制全屏重绘。简单粗暴，但在拖拽复杂组合体时会退化为全屏重绘（其实这通常是可以接受的，因为复杂组合体移动影响面积大）。

   * **方案 B**: 仅对“容器型”节点全屏重绘。

   * **方案 C**: 尝试快速估算子节点边界。

**用户场景**：拖拽“子部件超出父亲”。这暗示父节点在动，子节点跟着动。
如果父节点是 `Group`（无尺寸），目前逻辑是直接全屏重绘（`width <= 0`）。这是对的。
如果父节点是 `Sprite`（有尺寸），目前逻辑是局部重绘。**这是问题的根源**。

**修正** **`Node.ts`**：
在 `invalidateWithSelfBounds` 中，如果 `this.children.length > 0`，则：

* **直接全屏重绘**（为了安全和性能平衡）。

* 或者，递归计算包围盒（如果我们认为子节点数量不多）。

考虑到用户之前的抱怨是“缩放平移（全场景）卡顿”，那是成千上万个节点。
而拖拽一个组合体（通常子节点不会太多，几十个？），递归计算可能由于全屏重绘？
不，如果拖拽一个包含 1000 个子节点的 Sprite，递归计算还是很慢。

**最佳实践**：
如果节点有子节点，我们无法简单地知道子节点在哪里（可能在父节点外很远）。
为了保证正确性，**必须** 知道子节点的范围。
但在 WebGL 中，全屏重绘（Clear + Draw All Visible）通常比 CPU 递归计算 1000 个矩阵要快。
特别是当我们已经有了高效的 `isNodeVisible` 剔除。

**结论**：
**只要节点有子节点，就触发全屏重绘**（或者向上冒泡直到全屏）。
或者，更精细一点：
如果 `children.length > 0`，直接 `this.invalidate()` (无参数 -> 全屏)。

这会回退部分优化，但保证了正确性。
对于**叶子节点**（绝大多数 Sprite/Text），依然享受局部脏矩形优化。
对于**容器/组合体**，使用全屏重绘。

**修正代码**：
修改 `Node.ts` 的 `invalidateWithSelfBounds`。

```typescript
    private invalidateWithSelfBounds(changeFn: () => void) {
        // 1. 根节点、无尺寸容器、或**有子节点**的情况 -> 全屏重绘
        if (this.parent === null || (this.width <= 0 && this.height <= 0) || this.children.length > 0) {
            changeFn();
            this.updateTransform(this.parent ? this.parent.transform.worldMatrix : null, true);
            this.invalidate(); // 全屏
            return;
        }
        // ... 仅叶子节点走局部优化
    }
```

这样，当拖拽一个带有子部件的父节点时，会触发全屏重绘，从而清除子部件的旧影。

## 验证

* 平移/缩放场景（操作根节点）：根节点有子节点 -> 全屏重绘（正确）。

* 拖拽单个 Sprite（无子节点）：局部重绘（正确，高性能）。

* 拖拽组合体（Sprite + Children）：全屏重绘（正确，避免残影）。

这看起来是一个非常稳健的策略。
