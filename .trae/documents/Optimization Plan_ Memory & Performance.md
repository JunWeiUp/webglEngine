经过对项目的全面审查，我确定了几个关键的优化领域，主要集中在内存管理和渲染性能上。

### 1. **内存管理：瓦片缓存淘汰 (LRU)**
- **问题**：目前的 `TileLayer` 类将所有加载的瓦片缓存在 `Map` 中，没有任何淘汰策略。随着用户平移和缩放，内存占用将无限增长，最终可能导致浏览器崩溃。
- **解决方案**：为瓦片实现最近最少使用 (LRU) 缓存机制。
    - 跟踪每个瓦片的最后使用时间戳。
    - 定期（或在达到限制时）释放最近未使用的纹理。
    - 正确删除 WebGL 纹理以释放 GPU 内存。

### 2. **性能：异步纹理上传**
- **问题**：`TextureManager` 使用 `new Image()` 和 `onload` 加载纹理。纹理上传 (`texImage2D`) 发生在主线程上，在快速平移期间可能会导致掉帧（卡顿）。
- **解决方案**：切换到使用 `fetch` + `createImageBitmap`。
    - `createImageBitmap` 在主线程之外解码图像。
    - 它允许更流畅的纹理上传。
    - 启用 `AbortSignal` 支持，以取消不再需要的瓦片请求（例如，当用户快速划过时）。

### 3. **渲染效率：可见性与剔除**
- **问题**：虽然 `TileLayer` 计算了可见网格，但它会继续处理/加载那些在加载完成前就已经移出视野的瓦片。
- **解决方案**：将加载取消与可见性检查集成。如果一个瓦片排队等待加载但变得不可见（由于快速滚动），应中止其加载以节省带宽和 CPU。

### 实施计划
1.  **重构 `TextureManager.ts`**：
    - 添加对 `createImageBitmap` 和 `AbortSignal` 的支持。
    - 保持向后兼容性或重构现有用法。
2.  **更新 `TileLayer.ts`**：
    - 实现 LRU 缓存逻辑。
    - 集成新的 `TextureManager` 以加载带取消支持的瓦片。
    - 添加清理方法以释放资源。
3.  **验证**：
    - 验证长时间会话期间内存使用是否保持稳定。
    - 确保滚动感觉更流畅。

我是否应该继续进行这些优化？