用户的反馈表明目前的实现存在两个问题：
1.  **更卡了**：这是因为场景中交替渲染不同纹理的 Sprite（ContainerBG 和 Sprite1 交替），导致批处理频繁失效（每次纹理变化都会触发 Flush），实际上退化成了比之前更慢的逐个 Draw Call（因为增加了 Buffer 操作）。
2.  **图形不对**：这可能是因为频繁 Flush 导致的状态混乱，或者之前的顶点属性偏移量计算有细微错误。

**解决方案：实现多纹理批处理 (Multi-Texture Batching)**

我将通过在一个 Batch 中支持多个纹理（例如 8 个）来彻底解决性能问题。这样即使 Sprite 交替使用不同纹理，只要总纹理数不超过 8 个，就可以合并在同一个 Draw Call 中。

**具体步骤**：

1.  **修改 `Renderer.ts`**：
    *   增加 `textureSlots` 数组，用于缓存当前 Batch 使用的纹理。
    *   修改 `drawQuad`：不再比较 `currentTexture`，而是检查纹理是否在 `textureSlots` 中。
        *   如果在，使用对应的索引（0-7）。
        *   如果不在且插槽未满，添加到 `textureSlots` 并使用新索引。
        *   如果插槽已满，触发 `flush()`，清空插槽，再添加。
    *   更新顶点数据结构：增加 `textureIndex` 属性（现在是 9 个 float：x, y, u, v, r, g, b, a, texIndex）。
    *   修改 `flush()`：将 `textureSlots` 中的纹理分别绑定到 `gl.TEXTURE0` ~ `gl.TEXTURE7`。

2.  **修改 `shaders.ts`**：
    *   **Fragment Shader**：由于 WebGL 1 不支持动态索引采样器（`u_textures[i]`），我们需要写一串 `if-else` 语句，根据 `v_textureIndex` 决定从哪个 `u_textures[0...7]` 中采样。
    *   **Vertex Shader**：增加 `attribute float a_textureIndex` 并传递给 Fragment Shader。

3.  **检查并修正顶点属性偏移**：
    *   确保 `vertexAttribPointer` 的 `stride` 和 `offset` 与新的顶点结构（9 floats）完全匹配。

这将把 5000 次 Draw Call 降低到 1 次（或极少次），彻底解决卡顿问题，并修复渲染逻辑。