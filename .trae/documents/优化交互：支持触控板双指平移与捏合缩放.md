# 支持触控板平移与缩放 (Trackpad Panning & Zooming)

用户请求增加对触控板平移和缩放的支持。目前 `InteractionManager` 已经处理了 `wheel` 事件，但主要针对的是鼠标滚轮的缩放行为。

## 触控板事件分析

1.  **缩放 (Pinch-to-Zoom)**：
    *   在 Web 浏览器中，触控板的双指捏合通常会触发 `wheel` 事件，并且 `e.ctrlKey` 为 `true`。
    *   此时 `e.deltaY` 代表缩放量，而不是垂直滚动量。
    *   或者，浏览器可能会触发原生的 `gesturestart`, `gesturechange`, `gestureend` 事件（主要在 Safari/macOS 上）。但更通用的方式是拦截带有 `ctrlKey` 的 `wheel` 事件。

2.  **平移 (Two-finger Scroll)**：
    *   触控板的双指滑动通常会触发 `wheel` 事件。
    *   `e.deltaX` 和 `e.deltaY` 分别代表水平和垂直方向的滚动量。
    *   这与鼠标滚轮（通常只有 deltaY）不同。

## 现有逻辑回顾

目前的 `onWheel` 实现：
```typescript
    private onWheel(e: WheelEvent) {
        e.preventDefault();

        const zoomSpeed = 0.001;
        const scaleChange = 1 - e.deltaY * zoomSpeed;
        
        // ... 计算以鼠标为中心的缩放 ...
    }
```
这段代码将**所有**的 `wheel` 事件都视为缩放，而且只使用了 `deltaY`。这意味着：
*   如果用户用触控板双指滑动（本意是平移），会被误判为缩放（因为有 deltaY）。
*   如果用户用触控板双指横向滑动（deltaX），会被忽略。

## 改进计划

我们需要区分 **鼠标滚轮缩放**、**触控板平移** 和 **触控板缩放**。

**通用策略**：
1.  **检测触控板缩放 (Pinch)**：
    *   如果 `e.ctrlKey` 为 `true`，则判定为缩放（这是 Chrome/macOS 的标准行为）。
    *   缩放量通常由 `e.deltaY` 决定。

2.  **检测平移 (Scroll/Pan)**：
    *   如果 `e.ctrlKey` 为 `false`。
    *   此时 `deltaX` 和 `deltaY` 应该被解释为场景的平移（Panning）。
    *   这符合大多数地图应用（如 Google Maps）在触控板上的行为：双指滑动=平移，双指捏合=缩放。

3.  **兼容鼠标滚轮**：
    *   普通鼠标滚轮滚动时，`ctrlKey` 为 `false`，且通常只有 `deltaY`。
    *   如果按照上述“平移”逻辑，滚轮会变成垂直平移。
    *   **冲突**：用户习惯鼠标滚轮=缩放。
    *   **解决方案**：我们需要区分“鼠标滚轮”和“触控板滑动”。
        *   这在 DOM API 中很难完美区分。
        *   一种常见做法是：**默认滚轮=缩放**。
        *   如果检测到明显的 `deltaX`，或者事件流表现出高频小幅度的特征（触控板惯性），则视为平移？太复杂。
        *   **更标准的做法**：
            *   **鼠标滚轮 (Mouse Wheel)**：缩放。
            *   **触控板 (Trackpad)**：双指滑动=平移，捏合=缩放。
            *   **如何区分？** 很难。
            *   **替代方案**：参考 Figma/Miro 等设计软件：
                *   滚轮 = 垂直平移 (或缩放，取决于设置)。
                *   Ctrl + 滚轮 = 缩放。
                *   Shift + 滚轮 = 水平平移。
                *   触控板双指 = 平移。
                *   触控板捏合 = 缩放 (Ctrl + Wheel)。

    *   **Web 地图标准 (如 Mapbox/Leaflet)**：
        *   鼠标滚轮 = 缩放。
        *   触控板双指滑动 = 平移。
        *   这需要区分设备。浏览器没有直接 API。
        *   **启发式判断**：触控板事件的 `deltaMode` 通常是 `DOM_DELTA_PIXEL` (0)，而鼠标滚轮通常是 `DOM_DELTA_LINE` (1)。但这不绝对。

    *   **简化方案 (符合用户直觉)**：
        *   检查 `e.ctrlKey`。如果是 `true` -> **缩放**。
        *   如果 `e.ctrlKey` 是 `false`：
            *   检查 `e.metaKey` (Mac Command) 或其他修饰键？否。
            *   **关键判断**：如果用户想用触控板平移，通常会有 `deltaX`。如果只有 `deltaY` 且很大（整行），可能是鼠标滚轮。
            *   但是，让鼠标滚轮变成平移可能会让用户困惑（虽然这在长页面是标准的，但在地图应用中滚轮通常是缩放）。

    *   **最终决定**：
        1.  **缩放**：当 `e.ctrlKey` 按下（触控板捏合或 Ctrl+滚轮）时。
        2.  **平移**：当检测到触控板滑动特征（如 `deltaX` 不为 0，或根据用户设置）时。
        3.  **鼠标滚轮默认行为**：
            *   由于无法完美区分，我们保留 **普通滚轮 = 缩放** 的逻辑（这是目前代码的行为，也是许多 WebGL 地图的默认行为）。
            *   **新增**：如果检测到 `e.ctrlKey`，也作为缩放处理（兼容触控板捏合）。
            *   **新增**：如果用户**按住 Space 键** + 滚轮/滑动 -> 平移？
            *   或者，我们可以引入一个模式切换？

    *   **修正：更加现代的 Web 地图交互**
        *   **触控板捏合 (Pinch)** -> 浏览器发送 `ctrlKey + wheel` -> **缩放**。
        *   **触控板双指移动 (Pan)** -> 浏览器发送普通 `wheel` (包含 deltaX, deltaY) -> **平移**。
        *   **鼠标滚轮** -> 浏览器发送普通 `wheel` (通常只有 deltaY) -> **缩放**？
        *   **冲突点**：普通 `wheel` 既可能是触控板平移，也可能是鼠标缩放。
        *   **如何解决冲突？**
            *   利用 `e.deltaMode`？
            *   FireFox/Chrome 中，触控板通常产生 `deltaMode = 0 (PIXEL)`，鼠标滚轮产生 `deltaMode = 1 (LINE)`。
            *   这可以作为一个强有力的区分信号！

## 执行逻辑

修改 `InteractionManager.ts` 的 `onWheel` 方法：

1.  **检测缩放意图**：
    *   如果 `e.ctrlKey` 为 `true` (触控板捏合)：执行 **缩放**。
    *   如果 `e.deltaMode === 1` (鼠标滚轮)：执行 **缩放**。

2.  **检测平移意图**：
    *   如果 `e.deltaMode === 0` (触控板像素级滑动) 且 `!e.ctrlKey`：执行 **平移**。
        *   `scene.x -= e.deltaX`
        *   `scene.y -= e.deltaY`

这样可以完美支持：
*   鼠标滚轮 -> 缩放。
*   触控板捏合 -> 缩放。
*   触控板双指 -> 平移。

**注意**：`e.deltaMode` 在不同浏览器/OS 上可能表现不一致，但在 Chrome/Safari/Firefox 上大体可用。这是一个低风险的优化。

## 计划
1.  修改 `InteractionManager.ts` 的 `onWheel` 方法，实现基于 `deltaMode` 和 `ctrlKey` 的行为分发。
