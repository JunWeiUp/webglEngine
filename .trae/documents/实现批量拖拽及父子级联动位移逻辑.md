用户希望实现**“框选后批量拖拽”**的能力。这意味着如果用户已经通过框选选中了多个物体，然后点击其中任何一个选中的物体进行拖拽时，所有选中的物体都应该跟随鼠标移动，保持相对位置不变。

**现有逻辑分析**：
目前 `InteractionManager.ts` 中的拖拽逻辑（`onMouseMove` 中处理 `this.auxLayer.draggingNode`）只针对单个 `draggingNode` 进行位置更新。

**实施计划**：

1.  **修改 `InteractionManager.ts`**：
    *   **OnMouseDown**：
        *   当点击一个物体时，检查该物体是否已经在 `selectedNodes` 集合中。
        *   如果已选中（且没有按 Shift），则保持多选状态不变，并设置 `draggingNode` 为当前点击的物体（作为主拖拽对象）。
        *   如果没有选中，且没有按 Shift，则清除旧选择，只选中当前物体（现有的单选逻辑）。
    *   **OnMouseMove**：
        *   计算鼠标的移动增量（Delta）。
        *   不仅仅移动 `draggingNode`，而是遍历 `auxLayer.selectedNodes` 集合。
        *   对集合中的**每一个节点**，都应用相同的位移逻辑：
            *   注意：每个节点可能有不同的父节点，因此“屏幕空间的 Delta”映射到“局部空间的 Delta”对于每个节点可能不同（取决于其父节点的变换矩阵）。
            *   需要对每个选中的节点分别计算：`LocalDelta = ParentInverseWorld * ScreenDelta`。
    *   **OnMouseUp**：
        *   目前的 Reparent（换父节点）逻辑比较复杂，批量换父节点可能会引起混乱。
        *   **策略**：暂时只支持批量**移动**，不支持批量**Reparent**（或者只允许主拖拽对象触发 Reparent，其他跟随者只移动位置）。
        *   如果必须支持批量 Reparent，需要对每个选中节点执行 Reparent 逻辑。为了简化和稳健，建议先实现批量移动。如果用户拖拽到了新的容器上，我们可以尝试将所有选中节点都 Reparent 到该容器。

**详细步骤**：
1.  **Update `onMouseDown`**:
    *   If click on a node that is already in `selectedNodes`, do NOT clear selection. Just set `draggingNode` and proceed.
2.  **Update `onMouseMove`**:
    *   Iterate `auxLayer.selectedNodes`.
    *   For each node, calculate its own local delta based on its parent's world matrix inverse.
    *   Apply position update.
3.  **Update `onMouseUp` (Reparenting)**:
    *   If a valid target is found (`dragTargetNode`), iterate all `selectedNodes`.
    *   Reparent each one to the target, recalculating local positions to maintain world positions.

**风险点**：
*   性能：如果有几千个选中物体，实时计算逆矩阵可能会有开销。但通常框选几十个物体问题不大。对于海量物体，可以优化为只计算一次逆矩阵（如果它们在同一个父节点下）。通用做法是分别计算。
*   父子关系：如果选中的物体中包含父子关系的节点（例如选中了 A 和 A 的子节点 B），移动 A 会带动 B，再移动 B 会导致 B 移动两次。
    *   **解决方案**：在移动前，先过滤 `selectedNodes`，排除那些“祖先也在选中列表中”的节点。即只移动最顶层的选中节点。

**优化后的移动逻辑**：
1.  获取所有 `selectedNodes`。
2.  过滤出“Top Level Selected Nodes”（即其父节点不在 selectedNodes 中的节点）。
3.  只对这些 Top Level 节点应用位移。由于子节点会跟随父节点移动，这样就避免了双重移动。

**修改文件**：
*   `src/engine/events/InteractionManager.ts`

**计划**：
1.  Refactor `onMouseDown` to respect existing selection.
2.  Implement `getTopLevelSelectedNodes` helper.
3.  Update `onMouseMove` to move all top-level selected nodes.
4.  Update `onMouseUp` to reparent all top-level selected nodes (if target valid).