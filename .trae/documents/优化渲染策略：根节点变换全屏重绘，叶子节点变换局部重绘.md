# WebGL 渲染优化：区分平移缩放与其他更新

用户希望进一步优化渲染逻辑：**仅在平移/缩放场景时触发全屏重绘 (invalidateFull)，而其他情况（如单个节点移动）尽量使用脏矩形 (invalidateArea)**。

我们在之前的步骤中移除了 `Node` 的 `invalidateWithChange`，现在 `Node` 的属性变化只会触发无参数的 `invalidate()`，这默认会导致全屏重绘（如果 `Engine` 接收到无参数 `invalidate` 就全屏的话）。

为了满足用户的精细化需求，我们需要恢复部分脏矩形计算能力，但要避免之前的性能陷阱（递归计算全树包围盒）。

## 方案设计

1.  **Engine 层面**：
    *   保持 `invalidateFull()` 用于明确的全屏重绘需求（如根节点变换）。
    *   保持 `invalidateArea(rect)` 用于局部重绘。

2.  **Node 层面**：
    *   对于 **根节点** (Scene) 或 **特定的容器节点**：当其 `x, y, scale` 变化时，这意味着整个视口变化，应该调用 `invalidateFull()`。
    *   对于 **普通叶子节点** (Sprite, Text)：当其属性变化时，计算其自身的局部脏矩形（Local Bounds -> World Bounds），而不是递归计算整个子树。
    *   因为叶子节点通常没有子节点，或者子节点很少，计算其 World Bounds 是 O(1) 的，非常快。

## 关键修改点

我们需要在 `Node` 类中区分“影响全局的变换”和“局部变换”。但 `Node` 类是通用的，它不知道自己是不是根节点。

**策略调整：**
修改 `Node.ts` 的属性 setter：
*   如果节点是 `Scene` (根节点，没有 parent？或者 name 是 "Scene"？)，则触发全屏重绘。
*   否则，尝试计算该节点自身的 World AABB（仅自身，不递归合并子节点，或者仅浅层合并），然后触发 `invalidate(rect)`。

**具体实现细节**：
在 `Node` 类中：
1.  恢复 `invalidateWithChange` 的思想，但**极大简化**。
2.  在 setter 中：
    *   记录旧的 World AABB (仅自身 `width/height` 应用 `worldMatrix`)。
    *   更新变换。
    *   计算新的 World AABB。
    *   取并集，调用 `invalidate(rect)`。

**等待，之前的问题是 `getBounds(true)` 递归了子节点。**
如果我们只计算 `getBounds(false)`（不包含子节点），那么对于容器节点（自身无尺寸，全靠子节点撑开），脏矩形会是空的，导致渲染错误。

**折中方案**：
用户提到 "webgl只有在平移缩放场景才会触发invalidateFull"。
这通常指的是 **交互操作**（拖拽画布、滚轮缩放）导致的是根节点（或且仅有一个 World 容器）的变换。
而具体的某个 Sprite 移动，应该只触发局部重绘。

我们可以通过 `InteractionManager` 来控制。当交互导致根节点变换时，显式调用 `invalidateFull`。
但 `Node` 的 setter 是底层的。

**建议方案**：
在 `Node` 中判断：
*   如果 `this.parent === null` (根节点)，或者 `this.isSceneRoot` (如果能区分)，则 `invalidate()` (全屏)。
*   否则，计算 **自身** 的变化前后的 World AABB（`getBounds(false)`）。
    *   如果自身有尺寸（Sprite/Text），这很简单。
    *   如果自身无尺寸（Group），这很麻烦。但通常 Group 自己不动，动的是子节点。如果 Group 动了，通常意味着带着一堆子节点动，这时候计算包围盒又回到了之前的性能陷阱。

**最简化的优化**：
假设大部分“卡顿”来自于**根节点**的移动（平移/缩放整个地图）。
我们只需要在 `Node` 中检测：**如果我是根节点，直接全屏脏；否则，尝试计算局部脏。**

但是，如果移动了一个包含 1000 个子节点的 Group，我们还是不想递归计算。
对于 Group 移动，也许全屏重绘反而更划算？

**最终策略**：
1.  **根节点判断**：在 `Node` 的 `invalidate` 方法中，如果 `this.parent` 为空，视为根节点，传递 `undefined` 给 `onInvalidate`（触发全屏）。
2.  **叶子节点优化**：在 `Node` 的 setter 中，如果节点有 `width/height`（是实体节点），则计算脏矩形并调用 `invalidate(rect)`。
3.  **容器节点回退**：如果节点没有 `width/height`（是容器），则直接 `invalidate()`（全屏，或者让父级处理）。*注意：这可能会导致移动小容器也全屏重绘，但比递归计算几万个节点要安全。且 WebGL 全屏重绘很快。*

**修正 `Node.ts` 逻辑**：
```typescript
    set x(value: number) {
        if (this.x !== value) {
            // 1. 尝试获取轻量级脏矩形 (不递归)
            const oldRect = this.getSelfBounds(); 
            
            this.transform.setPosition(value, this.y);
            this.updateTransform(this.parent?.transform.worldMatrix, true); // 仅更新自身和子树矩阵，必须的
            
            const newRect = this.getSelfBounds();
            
            // 2. 决定失效策略
            if (this.parent === null) {
                this.invalidate(); // 根节点 -> 全屏
            } else if (oldRect && newRect) {
                 this.invalidate(union(oldRect, newRect)); // 实体节点 -> 局部
            } else {
                 this.invalidate(); // 容器节点 -> 全屏 (或无法计算)
            }
        }
    }
```
`getSelfBounds()`: 仅根据自身的 `width, height` 和 `worldMatrix` 计算 4 个角。O(1) 复杂度。

这样：
- **平移场景 (根节点)**：`parent === null` -> 全屏重绘。
- **移动 Sprite/Text**：有 `width/height` -> 计算局部脏矩形 -> 局部重绘。
- **移动 Group**：无 `width/height` -> 全屏重绘（避免递归爆炸）。

这完美符合用户需求：平移缩放场景（根节点）触发全屏，其他（实体节点）采用脏区域。

**补充**：`InteractionManager` 在处理拖拽/缩放时，是直接修改 `scene` 的属性吗？如果是，`scene.parent` 为 null，正好触发全屏。

## 验证
需要确认 `Node.ts` 中 `getBounds(false)` 是否就是 `getSelfBounds`。是的。
需要确认 `invalidate()` 无参数时，`Engine` 处理为全屏。是的。

## 执行
修改 `Node.ts` 的 setter，引入 `getBounds(false)` 的前后对比逻辑。
